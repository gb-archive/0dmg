# Day Two

Outstanding items from yesterday:

- correct endianness of register accessors.
- verify jump destination: is it off-by-one?
- verify implementation of `0xCB` `0x7C` bit-check.
- if that's all good, figure out what other problem is preventing our code from looping as expected.

I also rewatched some of [The Ultimate Game Boy Talk](https://youtu.be/HyzD8pNlpwI) again, and it gave me a couple other things to address soon:

- The "flag register" is just the the `F` register. Oops.
- The boot ROM is (at least initially) mapped to address `0x0` in memory. It should be easy to put it there, and start processing instructions through normal memory access.

My (incorrectly) big-endian byte- and bit-wise logic was duplicated across a few register accessor methods. It didn't look great.

    fn set_h_flag(&mut self, value: bool) {
        self.flag_register = (self.flag_register & 0b11011111) + (if value { 0b00100000 } else { 0 });
    }

While going to fix it, I decided to pull that out into a few utility functions. They initially looked like this:

    fn u8s_to_u16(a: u8, b: u8, x: &mut u16) {
        *x = a as u16 + ((b as u16) << 8)
    }

    fn u16_to_u8s(x: u16, a: &mut u8, b: &mut u8) {
        *a = x as u8;
        *b = (x >> 8) as u8;
    }

    fn u8_get_bit(x: u8, offset: u8) -> bool {
        (x >> offset) & 1 == 1
    }

    fn u8_set_bit(x: &mut u8, offset: u8, value: bool) {
        let mask = 1 << offset;
        if value {
            *x |= mask;
        } else {
            *x &= !mask;
        }
    }

With:

    fn set_h_flag(&mut self, value: bool) {
        u8_set_bit(&self.flag_register, 3, value)
    }

Typing an argument as `&mut u8` instead of `u8` is kind-of like using a pointer type in C, but more restricted. The `&` means that I am "borrowing" the value, so the compiler will ensure that I don't hold onto that reference longer than expected and do something unsafe. Since I'm just using it immediately before ending the function (and returning the "borrow"), there's no problem here. The `mut` annotation is required because I'm going to be mutating it. Rust seems to require `mut ` almost everything that you have non-strictly-functional behaviour. I love it! But I'm not really striving for a functional style here yet, so I'll probably be typing it a lot.

While implementing this, I ran across a quirky choice of Rust: functions implicitly return the last expression in their bodies, *unless* it's followed by a semicolon. So omitting the semicolon at the end is the same as adding `return` to the beginning. This looks clean, but is very strange and not obvious when looking at the source. It might normally bother me, but the compiler provides such precise error messages:

    error[E0308]: mismatched types
    --> src/main.rs:231:30
        |
    231 |       fn z_flag(&self) -> bool {
        |  ______________________________^
    232 | |         u8_get_bit(self.flag_register, 1);
        | |                                          - help: consider removing this semicolon
    233 | |     }
        | |_____^ expected bool, found ()
        |
        = note: expected type `bool`
                found type `()`

An easy one-character fix.

Unfortunately (or maybe fortunately), my idea of having `u16_to_u8s` write its results directly to two borrowed `&mut u8` references don't seem to be allowed. The function definition is fine, but when I go to use it, I get this error:

    error[E0499]: cannot borrow `self.main_registers[..]` as mutable more than once at a time
    --> src/main.rs:220:62
        |
    220 |         u16_to_u8s(value, &mut self.main_registers[10], &mut self.main_registers[11]);
        |                                -----------------------       ^^^^^^^^^^^^^^^^^^^^^^^- first borrow ends here
        |                                |                             |
        |                                |                             second mutable borrow occurs here
        |                                first mutable borrow occurs here

I guess the borrow checker doesn't understand that these references are to non-overlapping sections of memory, and is concerned that multiple mutable borrowings could mean that the array is modified from different places at once, unsafely. There may be some way to explain what I'm doing to the compiler more clearly, either by using some kind-of joint borrow, or a narrower one, with some kind of complicated lifetime annotation. But it's probably a better idea to just change the method to the functional style the language encourages.

Rather than requiring multiple "out parameters", Rust allows us to use tuples for multiple return values:

    fn u16_to_u8s(x: u16) -> (u8, u8) {
        (x as u8, (x >> 8) as u8)
    }

And supports destructuring assignment to easily consume them:

    fn set_pc(&mut self, value: u16) {
        let (p, c) = u16_to_u8s(value);
        self.main_registers[10] = p;
        self.main_registers[11] = c;
    }

With these changes finally compiling, we can run and get the next expected error:

    read opcode 0x32 at 0x7
    memory[HL] = A; HL -= 1
        memory[0x9FFF] = 0x0
    thread 'main' panicked at 'I don't know how to set address 0x9FFF.', src/main.rs:270:13

We had address mangled yesterday, so implemented support for a memory range other than the one we actually needed in this case, which is the main Video RAM.
