I have hit a threshold of basic understanding of the Game Boy and Rust now, and feel confident enough to try to refactor my spagetti soup into something sensible, if not idiomatic.

GameBoy { CPU, MemoryController, VideoController, AudioContoller, ... }

The components will still be more tightly coupled than they should be, but at least things like the (hypothetical) AudioController should be standalone.

I was starting to feel really good about potential performance, with one major exception: generating the log messages for each opcode would be a lot of overhead, way more than the operations themselves.

But it looks like defining a macro to exclude my logging from compilation in optimized builds won't be too hard. The code may just be something like this:

    macro_rules! log_unless_optimized {
        ($($arg:tt)*) => (if cfg!(debug_assertions) { Some($($arg)*) } else { None })
    }

Which I apply to my logging expressions like this:

    log_unless_optimized!(format!("..."), format!("..."))

Hey, I did that. It works!

I think I'm still failing to set the appropriate flag bits on a bunch of operations. The half-carry bit [seems like a wierd implementation detail](https://stackoverflow.com/q/8868396); I wonder if anything really depends on it.

---

Digesting [Exploring Rust fat pointers](https://iandouglasscott.com/2018/05/28/exploring-rust-fat-pointers/):

So in C++, for any class that has implemented abstract/virtual methods, every instance of that class includes a pointer to a "vtable", which maps the abstract function identifier to the actual implementation in memory. This is how you can have a use pointer to a *Printable object, without knowing its concrete type: you go into its vtable, and look up the function pointer.

This is very similar to a prototype, with the key distinction being that it only exists if it's required. (If the compiler statically knows what the type will be, it doesn't need a vtable loopup, and it won't be given one.)

This is mostly just an implementation details, but apparently in Rust, instead of including the vtable pointer in every struct (the overhead!), it's included a part of the *pointer*. Instead of just having the address of the instance in memory, the pointer also has the address of its vtable.

But these "fat pointers" are only used in cases where you need dynamic/generic dispatch. So if you use the same class somewhere it can be statically analyzed, it will just use a convention thin pointer.
